<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Protocols Hierarchical Map</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { margin: 0; font-family: sans-serif; overflow: hidden; }
    #graph { width: 100vw; height: 100vh; }
    .tooltip {
      position: absolute;
      text-align: left;
      width: 300px;
      padding: 8px;
      font-size: 13px;
      background: rgba(0,0,0,0.85);
      color: #fff;
      border-radius: 6px;
      pointer-events: none;
      opacity: 0;
    }
    .legend {
      position: absolute;
      top: 10px;
      left: 10px;
      background: white;
      border: 1px solid #ccc;
      padding: 8px;
      border-radius: 6px;
      font-size: 12px;
      max-height: 90vh;
      overflow-y: auto;
    }
    .legend div {
      display: flex;
      align-items: center;
      margin-bottom: 2px;
    }
    .legend span {
      width: 14px;
      height: 14px;
      display: inline-block;
      margin-right: 6px;
      border-radius: 3px;
    }
  </style>
</head>
<body>
<div id="graph"></div>
<div id="tooltip" class="tooltip"></div>
<div id="legend" class="legend"></div>

<script>
const data =
{
    "XmippProtLocalVolAdj": {
        "name": "volume local adjustment",
        "Description": "Protocol to adjust locally volume intensity to a reference volume. Occupancy volume is saved in protocol folder. Based on      https://www.sciencedirect.com/science/article/pii/S1047847723000874?via%3Dihub",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Calculators"
            ]
        ]
    },
    "XmippProtDeepRes": {
        "name": "local deepRes",
        "Description": "         A deep-learning-based method designed to estimate local resolution in cryo-electron microscopy maps. It analyzes 3D structural features directly from the map data to assign local resolution values to beach voxel of a 3D map.. Using models trained on simulated and experimental data, DeepRes provides spatially resolved estimates that reflect variations in structural clarity across the map. The method captures subtle improvements from post-processing steps, offering a refined view of resolution distribution that supports better interpretation and validation of cryo-EM structures.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Resolution"
            ]
        ]
    },
    "XmippProtReconstructHighRes": {
        "name": "highres",
        "Description": "This is a 3D refinement protocol whose main input is a volume and a set of particles.        The set of particles has to be at full size (the finer sampling rate available), but        the rest of inputs (reference volume and masks) can be at any downsampling factor.        The protocol scales the input images and volumes to a reasonable size depending on        the resolution of the previous iteration.                The protocol works with any input volume, whichever its resolution, as long as it        is a reasonable initial volume for the set of particles. The protocol does not        resolve the heterogeneous problem (it assumes an homogeneous population),        although it is somewhat tolerant through the use of particle weights in the        reconstruction process.                It is recommended to perform several global alignment iterations before entering        into the local iterations. The switch from global to local should be performed when        a substantial percentage of the particles do not move from one iteration to the next.                The algorithm reports the cross correlation (global alignment) or cost (local) function        per defocus group, so that we can see which was the percentile of each particle in its        defocus group. You may want to perform iterations one by one, and remove from one        iteration to the next, those particles that worse fit the model.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Refine"
            ]
        ]
    },
    "XmippProtMicDefocusSampler": {
        "name": "micrographs defocus sampler",
        "Description": "     Protocol to make a balanced subsample of meaningful CTFs in basis of the defocus values.     Both CTFs and micrographs will be output. CTFs with different defocus values look differently,     while low defocus images will have bigger fringes, higher defocus values will have more compact rings.     Micrographs with a greater defocus will have more contrast.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Sets"
            ]
        ]
    },
    "XmippProtConsensusClasses": {
        "name": "consensus classes",
        "Description": " Compare several SetOfClasses.         Return the consensus clustering based on a objective function         that uses the similarity between clusters intersections and         the entropy of the clustering formed.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Classify"
            ]
        ]
    },
    "XmippProtAssignmentTiltPair": {
        "name": "assign tiltpairs",
        "Description": "         Determines the affine transformation between two sets of points obtained from tilted micrograph pairs. This transformation aligns coordinate sets for accurate particle matching and analysis.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Picking"
            ]
        ]
    },
    "XmippProtCTFCorrectWiener2D": {
        "name": "ctf_correct_wiener2d",
        "Description": "          Performs CTF correction on images using Wiener filtering in 2D. This method enhances image quality by reducing noise and compensating for the contrast transfer function effects in the micrographs or particle images. Use it with caution, preferably only for visualization purposes or when subsequent methods demand it explicitly.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Preprocess"
            ]
        ]
    },
    "XmippProtPickingRemoveDuplicates": {
        "name": "remove duplicates",
        "Description": "     This protocol removes coordinates that are closer than a given threshold.     The remaining coordinate is the average of the previous ones.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Picking"
            ]
        ]
    },
    "XmippProtResolution3D": {
        "name": "resolution 3D",
        "Description": " Computes the resolution of 3D volumes using the Fourier Shell Correlation (FSC) criteria. The protocol requires two volumes, which are assumed to be independently reconstructed. In addition, the protocol can also compute the B-factor for the volumes. ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Resolution"
            ]
        ]
    },
    "XmippProtShiftVolume": {
        "name": "shift volume",
        "Description": " Shifts a 3D volume spatially according to user-provided parameters.",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Calculators"
            ]
        ]
    },
    "XmippProtLocSharp": {
        "name": "localdeblur sharpening",
        "Description": "         Calculates sharpened maps based on a given resolution map. The sharpening process enhances high-resolution features by boosting contrast where the local resolution allows to do so.     ",
        "Tags": [
            [
                "Model building",
                "Preprocess map"
            ]
        ]
    },
    "XmippProtGenerateReprojections": {
        "name": "generate reprojections",
        "Description": "Compares a set of classes or averages with the corresponding projections of a reference volume.     The set of images must have a 3D angular assignment and the protocol computes the residues     (the difference between the experimental images and the reprojections). The zscore of the mean     and variance of the residues are computed. Large values of these scores may indicate outliers.     The protocol also analyze the covariance matrix of the residual and computes the logarithm of     its determinant [Cherian2013]. The extremes of this score (called zScoreResCov), that is     values particularly low or high, may indicate outliers.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtApplyTransformationMatrix": {
        "name": "apply transformation matrix",
        "Description": "      Apply transformation matrix  of an aligned volume on      a set of particles to modify their angular assignment.     Note:     These particles are practically related to the      aligned volume (but before alignment).     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Preprocess"
            ]
        ]
    },
    "XmippProtDeepCenter": {
        "name": "deep center",
        "Description": "Center a set of particles in 2D using a neural network. The particles remain the same, but their alignment        includes an approximate shift to place them in the center. This protocol performs the training of the model. ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Align"
            ]
        ]
    },
    "XmippProtMovieDoseAnalysis": {
        "name": "movie dose analysis",
        "Description": "     Analyzes the electron dose applied throughout a movie acquisition. This protocol helps assess dose accumulation and its effects on image quality, providing information essential for dose weighting and optimizing reconstruction..     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtMonoDir": {
        "name": "directional resolution MonoDir",
        "Description": "         Asseses directional local resolution values of a 3D map. Enables identifying angular assignment errors and possible preferential directions. This method uses monores local resolution algorithm in a directional manner.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Resolution"
            ],
            [
                "3D",
                "Analysis",
                "Resolution"
            ]
        ]
    },
    "XmippProtConsensusPicking": {
        "name": "picking consensus",
        "Description": "     Protocol to estimate the agreement between different particle picking     algorithms. The protocol takes several Sets of Coordinates calculated     by different programs and/or different parameter settings. Let's say:     we consider N independent pickings. Then, a coordinate is considered     to be a correct particle if M pickers have selected the same particle     (within a radius in pixels specified in the form).      If you want to be very strict, then set M=N; that is, a coordinate     represents a particle if it has been selected by all particles (this     is the default behaviour). Then you may relax this condition by setting     M=N-1, N-2, ...      If you want to be very flexible, set M=1, in this way it suffices that     1 picker has selected the coordinate to be considered as a particle. Note     that in this way, the cleaning of the dataset has to be performed by other     means (screen particles, 2D and 3D classification, ...).     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Picking"
            ]
        ]
    },
    "XmippProtVolSubtraction": {
        "name": "volumes subtraction",
        "Description": " This protocol scales a volume in order to adjust it to another one. Then, it can calculate the subtraction     of the two volumes. Second input can be a pdb. The volumes should be aligned previously and they have to     be equal in size",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Calculators"
            ]
        ]
    },
    "XmippProtVolAdjust": {
        "name": "volume adjust",
        "Description": " This protocol scales a volume in order to assimilate it to another one.     The volume with the best resolution should be the first one.     The volumes should be aligned previously and they have to be equal in size",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Calculators"
            ]
        ]
    },
    "XmippProtCTFCorrectPhase2D": {
        "name": "ctf_correct_phase",
        "Description": "         Perform CTF correction by phase flip.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Calculators"
            ]
        ]
    },
    "XmippProtParticlePicking": {
        "name": "manual-picking (step 1)",
        "Description": " Picks particles in a set of micrographs     either manually or in a supervised mode.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Picking"
            ]
        ]
    },
    "XmippProtCTFDefocusGroup": {
        "name": "defocus group",
        "Description": "     Given a set of CTFs group them by defocus value.     The output is a metadata file containing       a list of defocus values that delimite      each defocus group.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Sets"
            ]
        ]
    },
    "XmippProtClassifyPcaStreaming": {
        "name": "2D classification pca streaming",
        "Description": " Performs a 2D classification of particles using PCA. This method is optimized to run in streaming, enabling efficient processing of large datasets.  ",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Sets"
            ]
        ]
    },
    "XmippProtRCT": {
        "name": "random conical tilt",
        "Description": "Creates initial 3D volumes using 2D classes and particle pairs from tilted images. Applies the Random Conical Tilt (RCT) method to generate unbiased starting volume for structure refinement, even with a small number of image pairs. The volume serves as starting models for further refinement steps. ",
        "Tags": [
            [
                "Random Conical Tilt"
            ]
        ]
    },
    "XmippProtValidateOverfitting": {
        "name": "validate overfitting",
        "Description": "         Check how the resolution changes with the number of projections used for      3D reconstruction.       NOTE:     Using the output plot, with the reconstruction of aligned gaussian noise,     you can assess the validity of the reconstruction from your micrograph     images. Practically, if the resolution of reconstruction based on your     images is not considerably different from aligned gaussian noise one     (for less number of particles),your images may not produce a valid     reconstruction.      This method has been proposed by:     B. Heymann \"Validation of 3D EM Reconstructions\", 2015.     (see References)     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtML2D": {
        "name": "ml2d",
        "Description": "     Perform (multi-reference) 2D-alignment using      a maximum-likelihood ( *ML* ) target function.          Initial references can be generated from random subsets of the experimental     images or can be provided by the user (this can introduce bias). The output     of the protocol consists of the refined 2D classes (weighted averages over      all experimental images). The experimental images are not altered at all.              Although the calculations can be rather time-consuming (especially for      many, large experimental images and a large number of references we      strongly recommend to let the calculations converge.      ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Classify"
            ]
        ]
    },
    "XmippProtMovieGain": {
        "name": "movie gain",
        "Description": " Estimate the gain image of a camera, directly analyzing one of its movies.     It can correct the orientation of an external gain image (by comparing it with the estimated).     Finally, it estimates the residual gain (the gain of the movie after correcting with a gain).     The gain used in the correction will be preferably the external gain, but can also be the estimated     gain if the first is not found.     The same criteria is used for assigning the gain to the output movies (external corrected > external > estimated)     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtCTFMicrographs": {
        "name": "ctf estimation",
        "Description": " Estimates the contrast transfer function (CTF) parameters on a set of micrographs using Xmipp, as well as other useful parameters such as ice thickness or information decay rate. Accurate CTF estimation is essential for correcting image distortions and improving resolution. It is recommended to use over the defocus calculated by other means (ie CTFFIND, gCTF or Warp). ",
        "Tags": [
            [
                "Protocols SPA",
                "Micrographs",
                "CTF estimation"
            ]
        ]
    },
    "XmippProtParticlePickingPairs": {
        "name": "tilt pairs particle picking",
        "Description": " Picks particles in paired tilted micrographs. Using paired data improves particle localization and orientation determination, enhancing reconstruction accuracy. ",
        "Tags": [
            [
                "Random Conical Tilt"
            ]
        ]
    },
    "XmippProtApplyAlignment": {
        "name": "apply alignment 2d",
        "Description": " Applies previously calculated alignment parameters to a set of images, producing a new aligned dataset. This step is critical for improving the consistency and quality of images before further analysis or reconstruction. ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Align"
            ]
        ]
    },
    "XmippProtHelicalParameters": {
        "name": "helical symmetry",
        "Description": "Estimates the helical symmetry and parameters of a structure. Helical symmetry is defined mathematically as V(r,rot,z)=V(r,rot+k*DeltaRot,z+k*Deltaz) and applied to improve the reconstruction of the volume specimens inthe processing. You can limit the radios of the helix, apply dihedral symmetry and apply Cn symmetry    ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtPreprocessMicrographs": {
        "name": "preprocess micrographs",
        "Description": "This protocol preprocesses micrographs by performing several operations: cropping borders, take logarithm in order to have a linear relationship, removing bad pixels, invert contrast, downsampling micrograph, denoising, normalize the micrograph, gaussian filter and low or high filter. These steps help improve data quality before particle picking and reconstruction.",
        "Tags": [
            [
                "Protocols SPA",
                "Micrographs",
                "Preprocess"
            ]
        ]
    },
    "XmippProtLocalCTF": {
        "name": "estimate local defocus",
        "Description": "Compares a set of particles with the corresponding projections of a reference volume.     The set of particles must have a 3D angular assignment.     This protocol refines the CTF, computing local defocus change.     The maximun allowed defocus is a parameter introduced by the user (advanced).     The protocol gives back the input set of particles with the refine local defocus and the defocus change with relation to the global defocus.",
        "Tags": [
            [
                "Protocols SPA",
                "Micrographs",
                "CTF estimation"
            ],
            [
                "3D",
                "Refine"
            ]
        ]
    },
    "XmippProtEliminateEmptyParticles": {
        "name": "eliminate empty particles",
        "Description": " Takes a set of particles and using statistical methods     (variance of variances of sub-parts of input image) eliminates those samples,     where there is no object/particle (only noise is presented there).     Threshold parameter can be used for fine-tuning the algorithm for type of data.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Extract"
            ]
        ]
    },
    "XmippProtEliminateEmptyClasses": {
        "name": "eliminate empty classes",
        "Description": " Takes a set of classes (or averages) and using statistical methods     (variances of sub-parts of input image) eliminates those samples,     where there is no object/particle (only noise is presented there).     Threshold parameter can be used for fine-tuning the algorithm for     type of data. Also discards classes with less population than a given     percentage.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Extract"
            ]
        ]
    },
    "XmippProtValidateNonTilt": {
        "name": "validate_nontilt",
        "Description": "         Ranks a set of volumes based on alignment reliability using a clusterability test. This validation helps identify well-aligned structures and discard poorly aligned or inconsistent reconstructions, improving final data quality.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtMonoRes": {
        "name": "local MonoRes",
        "Description": "         Assigns local resolution values to each voxel within a given 3D map, providing detailed insight into regional map quality. This aids in interpreting structural data by highlighting areas of varying resolution.     ",
        "Tags": [
            [
                "Model building",
                "Preprocess map"
            ]
        ]
    },
    "XmippProtStructureMapZernike3D": {
        "name": "struct map - Zernike3D",
        "Description": " Protocol for structure mapping based on Zernike3D. ",
        "Tags": [
            [
                "Model building",
                "Preprocess map"
            ]
        ]
    },
    "XmippProtCenterParticles": {
        "name": "center particles",
        "Description": " Recenters particles that are initially un-centered by computing alignment shifts relative to a reference point. Proper centering enhances the accuracy of subsequent classification and refinement steps. ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Extract"
            ]
        ]
    },
    "XmippProtRotationalSymmetry": {
        "name": "rotational symmetry",
        "Description": "     Estimate the orientation of a rotational axis and symmetrize.     The user should know the order of the axis (two-fold, three-fold, ...)     If this is unknown you may try several and see the most consistent results.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtMultipleFSCs": {
        "name": "multiple fscs",
        "Description": "     Compute the FSCs between a reference volume and a set of input volumes.     A mask can be provided and the volumes are aligned by default.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Resolution"
            ]
        ]
    },
    "XmippProtConvertPdb": {
        "name": "convert pdbs to volumes",
        "Description": "  Converts atomic structure files in PDB (Protein Data Bank) format into volumetric maps. Converting a PDB to a volume generates a simulated electron density map, useful for validating atomic models, fitting into experimental maps or performing docking.",
        "Tags": [
            [
                "Model building",
                "Tools-Calculators"
            ]
        ]
    },
    "XmippProtAngularGraphConsistency": {
        "name": "angular graph consistency",
        "Description": "     Performs soft alignment validation of a set of particles previously aligned     confronting them using Graph filtered correlations representation. This     protocol produces an histogram with two groups of particles.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtPickNoise": {
        "name": "pick noise",
        "Description": "Protocol designed pick noise particles in micrographs and not real particles. The protocol allows you to choose the number of noise particles to extract from each micrograph. Set to -1 for extracting the same amount of noise particles as the number true particles for that micrograph ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Picking"
            ]
        ]
    },
    "XmippProtCompareAngles": {
        "name": "compare angles",
        "Description": "         Compare two sets of angles. The output is a list of all common particles with     the angular difference between both assignments. The output is constructed by      keeping the information from the Set 1 and adding the shiftDiff and angularDiff.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtApplyTiltToCtf": {
        "name": "apply tilt to ctf",
        "Description": " Applies a local deviation correction to the particleâ€™s contrast transfer function (CTF) estimation based on the tilt angle of the micrograph. This adjustment improves reconstruction quality, especially for tilted samples.",
        "Tags": [
            [
                "Tomography",
                "TiltSeries"
            ]
        ]
    },
    "XmippProtDeepCenterPredict": {
        "name": "deep center predict",
        "Description": "Center a set of particles in 2D using a neural network. The particles remain the same, but their alignment        includes an approximate shift to place them in the center. This protocol only predicts, it does not train. ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Align"
            ]
        ]
    },
    "XmippProtNormalizeStrain": {
        "name": "normalize strain",
        "Description": "     Normalize the local strain and rotations amongst several runs     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Heterogeneity"
            ]
        ]
    },
    "XmippProtReconstructSwarm": {
        "name": "swarm consensus",
        "Description": "This is a 3D refinement protocol whose main input is a set of volumes and a set of particles.        The set of particles has to be at full size (the finer sampling rate available), but        the rest of inputs (reference volume and masks) can be at any downsampling factor.        The protocol scales the input images and volumes to a size that depends on the target resolution.         The input set of volumes is considered to be a swarm of volumes and they try to optimize        the correlation between the volumes and the set of particles. This is an stochastic maximization        and only a fraction of the particles are used to update the volumes and evaluate them.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Initial volume"
            ]
        ]
    },
    "XmippProtCL2DMap": {
        "name": "2D classes mapping",
        "Description": " Create a low dimensional mapping from a SetOfClasses2D with interactive selection of classes.     Use mouse left-click to select/deselect classes individually or mouse right-click to select/deselect     several classes.",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Classify"
            ]
        ]
    },
    "XmippProtValFit": {
        "name": "validate fsc-q",
        "Description": "    Assesses the quality of the fit between a model and experimental data. This protocol evaluates how well a volume or structure matches reference data, guiding improvements in model accuracy.     ",
        "Tags": [
            [
                "Model building",
                "Validation"
            ]
        ]
    },
    "XmippProtShiftParticles": {
        "name": "shift particles",
        "Description": " This protocol shifts particles to center them into a point selected in a volume. To do so, it generates new     shifted images and modify the transformation matrix according to the shift performed.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Initial volume"
            ]
        ]
    },
    "XmippProtRansac": {
        "name": "ransac",
        "Description": "      Computes an initial 3d model from a set of projections/classes      using RANSAC algorithm.          This method is based on an initial non-lineal dimensionality     reduction approach which allows to select representative small      sets of class average images capturing the most of the structural      information of the particle under study. These reduced sets are      then used to generate volumes from random orientation assignments.      The best volume is determined from these guesses using a random      sample consensus (RANSAC) approach.          ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Initial volume"
            ]
        ]
    },
    "XmippProtAlignVolume": {
        "name": "align volume",
        "Description": "      Aligns a set of 3D volumes using cross-correlation or Fast Fourier Transform methods. The alignment allows direct comparison or averaging of volumes by bringing them into a common spatial frame.      ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtAlignVolumeForWeb": {
        "name": "align volume",
        "Description": "      Aligns a set of 3D volumes using cross-correlation or Fast Fourier Transform methods. The alignment allows direct comparison or averaging of volumes by bringing them into a common spatial frame.      ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtKerdensom": {
        "name": "kerdensom",
        "Description": "     Classifies a set of images using  Kohonen's Self-Organizing Feature Maps (SOM)      and Fuzzy c-means clustering technique (FCM) .          The kerdenSOM algorithm anneals from an initial high regularization factor     to a final lower one, in a user-defined number of steps.          KerdenSOM is an excellent tool for classification, especially when     using a large number of data and classes and when the transition between     the classes is almost continuous, with no clear separation between them.          The input images must be previously aligned.     ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Classify"
            ]
        ]
    },
    "XmippApplyZernike3D": {
        "name": "apply deformation field - Zernike3D",
        "Description": " Applies deformation to atomic structures using Zernike3D basis functions. This allows flexible modeling of structural variations in atomic models to better fit experimental density maps.  ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Classify"
            ]
        ]
    },
    "XmippProtVolConsensus": {
        "name": "volume consensus",
        "Description": " This protocol performs a fusion of all the input volumes, which should be preprocessed with protocol 'volume     substraction' saving volume 2, in order to be as similar as possible before the fusion. The output of     this protocol is the consensus volume and another volume which indicates the maximun difference between input     volumes in each voxel.",
        "Tags": [
            [
                "Tomography",
                "Subtomogram averaging",
                "PostProcessing"
            ]
        ]
    },
    "XmippProtSplitFrames": {
        "name": "split frames",
        "Description": "     Wrapper protocol for Xmipp Split Odd Even. It separates movie frames into two outputs based on whether their index is odd or even. This allows for independent processing of each group, helping to reduce noise and artifacts in cryo-EM data analysis.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtDeepVolPostProc": {
        "name": "deepEMhancer",
        "Description": "         Given a map the protocol performs automatic deep post-processing to enhance visualization. Usage guide at     https://github.com/rsanchezgarc/deepEMhancer     ",
        "Tags": [
            [
                "Model building",
                "Preprocess map"
            ]
        ]
    },
    "XmippProtClassifyPca": {
        "name": " 2D classification pca ",
        "Description": " 'Classifies a set of images using Principal Component Analysis (PCA). This 2D classification groups (the number of groups can be set) are based on their similarities, assisting in the identification of different conformational states or particle populations.'     ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Classify"
            ]
        ]
    },
    "XmippProtCL2DClustering": {
        "name": "clustering 2d classes",
        "Description": "Groups similar 2D class averages using clustering. This process helps identify homogeneous subsets within the dataset, improving classification and downstream analysis. ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Classify"
            ]
        ]
    },
    "XmippProtScreenParticles": {
        "name": "screen particles",
        "Description": "Protocol to attach different merit values to every particle metadata for subsequent pruning the set. There are different merit values to be calculated:     - zScore evaluates the similarity of a particles with an average (lower zScore -> higher similarity).     - SSNR evaluates the signal/noise ration in the Fourier space.     - Variance evaluates the varaince on the micrographs context where the particle was picked.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Extract"
            ]
        ]
    },
    "XmippProtAnalyzeLocalCTF": {
        "name": "analyze local defocus",
        "Description": "Assigns to each micrograph a coefficient (R2) which evaluates the result of the         local defocus adjustment and displays the local defocus for all the particles in each micrograph.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis"
            ]
        ]
    },
    "XmippProtCL2D": {
        "name": "cl2d",
        "Description": " Classifies a set of 2D images using clustering algorithms. It subdivides the original dataset into user-defined classes, aiding the identification of particle heterogeneity or structural variations within the data. ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Classify"
            ],
            [
                "2D",
                "Classify"
            ]
        ]
    },
    "XmippProtReconstructSignificant": {
        "name": "reconstruct significant",
        "Description": "     This algorithm addresses the initial volume problem in SPA     by setting it in a Weighted Least Squares framework and     calculating the weights through a statistical approach based on     the cumulative density function of different image similarity measures.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Initial volume"
            ]
        ]
    },
    "XmippProtCTFConsensus": {
        "name": "ctf consensus",
        "Description": "     Protocol to make a selection of meaningful CTFs in basis of the defocus     values, the astigmatism, the resolution, other Xmipp parameters, and     the agreement with a secondary CTF for the same set of micrographs.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Micrographs",
                "CTF estimation"
            ]
        ]
    },
    "XmippProtbfactorResolution": {
        "name": "local resolution/local bfactor",
        "Description": "         Given a local resolution map and an atomic model, this protocols provides the matching between the     local resolution with the local bfactor per residue.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Resolution"
            ]
        ]
    },
    "XmippProtExtractParticles": {
        "name": "extract particles",
        "Description": "Extracts particle images from micrographs based on provided coordinates. This essential step prepares particle stacks for further processing such as classification and reconstruction.",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Extract"
            ]
        ]
    },
    "XmippProtMultiRefAlignability": {
        "name": "multireference alignability",
        "Description": "         Performs soft alignment validation of a set of particles confronting them     against a given 3DEM map. This protocol produces particle alignment     precision and accuracy parameters.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtConsensusMovieAlignment": {
        "name": "movie alignment consensus",
        "Description": "     The protocol compares two sets of aligned movies (reference and secondary) to evaluate their alignment consistency.     It calculates the correlation between shift trajectories, allowing for a minimum correlation threshold to be set.     Movies with correlations below this threshold can be discarded. The protocol can also generate plots showing     the trajectories and correlations for each movie. This helps in identifying and validating the quality of movie alignments     based on consensus among different alignment runs.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtRotateVolume": {
        "name": "rotate volume",
        "Description": " Rotates a 3D volume around the x, y, and z axes by specified angles. This protocol allows flexible repositioning of volumes for alignment, comparison, or visualization. ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtCoreAnalysis": {
        "name": "core analysis",
        "Description": " Analyzes the core of a 2D classification. The core is calculated through     the Mahalanobis distance from each image to the center of the class. ",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Classify"
            ]
        ]
    },
    "XmippProtConsensusLocalCTF": {
        "name": "consensus local defocus",
        "Description": "This protocol compares local defocus estimations obtained from multiple protocols for a set of particles. It evaluates the consistency among different CTF estimates and generates a set of particles with a consensus defocus.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis"
            ]
        ]
    },
    "XmippParticlePickingAutomatic": {
        "name": "auto-picking (step 2)",
        "Description": "Automatically picks particles from a set of micrographs using a previously trained model. This protocol speeds up particle selection by identifying particles consistently without manual intervention, improving throughput.",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Picking"
            ]
        ]
    },
    "XmippProtFSO": {
        "name": "resolution fso",
        "Description": "         Given two half maps the protocol estimates Fourier Shell Occupancy to determine the global anisotropy of the map.     See more information here: https://github.com/I2PC/xmipp/wiki/FSO---Fourier-Shell-Occupancy     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Resolution"
            ]
        ]
    },
    "XmippProtPhantom": {
        "name": "phantom volume",
        "Description": " Creates a phantom volume based on a feature description file by using the xmipp_phantom_create tool. This synthetic volume can be used to test and validate algorithms or processing pipelines under controlled conditions. ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Initial volume"
            ]
        ]
    },
    "XmippProtTriggerData": {
        "name": "trigger data",
        "Description": "     Waits until certain number of images is prepared and then     send them to output.     It can be done in 3 ways:         - If \"Send all items to output?\" is _No_:             Once the number of items is reached, a setOfImages is returned and             the protocol finishes (ending the streaming from this point).         - If \"Send all items to output?\" is _Yes_ and:             - If \"Split items to multiple sets?\" is _Yes_:                 Multiple closed outputs will be returned as soon as                 the number of items is reached.             - If \"Split items to multiple sets?\" is _No_:                 Only one output is returned and it is growing up in batches of                 a certain number of items (completely in streaming).     ",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Sets"
            ]
        ]
    },
    "XmippProtFlexAlign": {
        "name": "FlexAlign",
        "Description": "     Wrapper protocol for Xmipp Movie Alignment using cross-correlation methods. It aligns movie frames to produce beam-induced motion corrected micrographs.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtExtractParticlesPairs": {
        "name": "extract particle pairs",
        "Description": "Extracts particles based on coordinates from tilted pairs of micrographs.",
        "Tags": [
            [
                "Random Conical Tilt"
            ]
        ]
    },
    "XmippProtAngBreakSymmetry": {
        "name": "break symmetry",
        "Description": "     Given an input set of particles with angular assignment, find an     equivalent angular assignment for a given symmetry.      Be aware that input symmetry values follows Xmipp conventions as described in:     https://i2pc.github.io/docs/Utils/Conventions/index.html#symmetry     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtVolumeDeformZernike3D": {
        "name": "volume deform - Zernike3D",
        "Description": "  Performs volume deformation based on Zernike3D functions, allowing flexible adjustments of 3D maps. This protocol aids in modeling conformational changes or correcting structural distortions in volumes.. ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtAlignVolumeParticles": {
        "name": "align volume and particles",
        "Description": "      Aligns a volume (inputVolume) using a Fast Fourier method     with respect to a reference one (inputReference).      The obtained alignment parameters are used to align the set of particles or subtomograms      (inputParticles) that generated the input volume.      ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtVolumeStrain": {
        "name": "calculate strain",
        "Description": "Compares two volume states to analyze local strains and rotations. This protocol helps study structural changes by quantifying deformation and dynamic behavior between different conformations.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Heterogeneity"
            ]
        ]
    },
    "XmippProtDeepMicrographScreen": {
        "name": "deep micrograph cleaner",
        "Description": "Removes coordinates located in carbon regions or large impurities in micrographs using a pre-trained deep learning model. This screening improves particle picking accuracy by filtering out false positives from contaminated areas.",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Picking"
            ]
        ]
    },
    "XmippProtCompareReprojections": {
        "name": "compare reprojections",
        "Description": "Compares a set of classes or averages with the corresponding projections of a reference volume.     The set of images must have a 3D angular assignment and the protocol computes the residues     (the difference between the experimental images and the reprojections). The zscore of the mean     and variance of the residues are computed. Large values of these scores may indicate outliers.     The protocol also analyze the covariance matrix of the residual and computes the logarithm of     its determinant [Cherian2013]. The extremes of this score (called zScoreResCov), that is     values particularly low or high, may indicate outliers.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtScreenDeepConsensus": {
        "name": "deep consensus picking",
        "Description": " Protocol to compute a smart consensus between different particle picking         algorithms. The protocol takes several Sets of Coordinates calculated         by different programs and/or different parameter settings. Let's say:         we consider N independent pickings. Then, a neural network is trained         using different subset of picked and not picked cooridantes. Finally,         a coordinate is considered to be a correct particle according to the         neural network predictions.         In streaming, the network is trained and used to predict in batches.         The network is trained until the number of particles set is reached,         meanwhile, a preliminary output is generated. Once the threshold is reached,         the final output is produced by batches.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Picking"
            ]
        ]
    },
    "XmippProtExtractUnit": {
        "name": "extract asymmetric unit",
        "Description": " Generates the necessary files for volumes and Fourier Shell Correlation (FSC) curves to submit structural data to the Electron Microscopy Data Bank (EMDB). This protocol ensures proper formatting and data preparation for public deposition.     ",
        "Tags": [
            [
                "Model building",
                "Preprocess map"
            ]
        ]
    },
    "XmippProtCL2DAlign": {
        "name": "align with cl2d",
        "Description": " Aligns a set of particles using the CL2D algorithm, allowing for an optional reference 2D image. Accurate alignment is critical for improving class averages and achieving high-quality 2D classifications.",
        "Tags": [
            [
                "Protocols SPA",
                "2D",
                "Align"
            ]
        ]
    },
    "XmippProtCreateGallery": {
        "name": "create gallery",
        "Description": "     Create a gallery of projections from a volume.     This gallery of projections may help to understand the images     observed in the microscope.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtDeepHand": {
        "name": "deep hand",
        "Description": "Predicts the handedness of a structure using a trained deep learning model. Determining correct handedness is essential in cryo-EM to ensure the accurate interpretation of 3D reconstructions.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Analysis",
                "Validation"
            ]
        ]
    },
    "XmippProtReconstructFourier": {
        "name": "reconstruct fourier",
        "Description": "         Reconstruct a volume using Xmipp_reconstruct_fourier from a given set of particles.     The alignment parameters will be converted to a Xmipp xmd file     and used as direction projections to reconstruct.     ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Reconstruct"
            ]
        ]
    },
    "XmippProtSubtractProjection": {
        "name": "subtract projection",
        "Description": " This protocol computes the subtraction between particles and a reference volume, by computing its projections with the same angles that input particles have. Then, each particle and the correspondent projection of the reference volume are numerically adjusted and subtracted using a mask which denotes the region to keep. ",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Calculators"
            ]
        ]
    },
    "XmippProtBoostParticles": {
        "name": "boost particles",
        "Description": " This protocol tries to boost the frequencies of the particles to imporve them, based on an adjustment on its correspondent projections from a reference volume. ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Postprocess"
            ]
        ]
    },
    "XmippProtTiltAnalysis": {
        "name": "tilt analysis",
        "Description": " Estimates the tilt angle of a micrograph by analyzing power spectral density correlations across different image quadrants. This helps discard the ones that have a tilt so high it could negatively affect the posterior processing.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Micrographs",
                "Preprocess"
            ]
        ]
    },
    "XmippProtStructureMap": {
        "name": "struct map",
        "Description": " Performs structure mapping based on correlation distance between volumes. This protocol helps identify similarities and differences among multiple structures by quantifying their spatial relationships.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Classify"
            ]
        ]
    },
    "XmippProtMovieMaxShift": {
        "name": "movie maxshift",
        "Description": "     Protocol to make an automatic rejection of those movies whose     frames move more than a given threshold.         Rejection criteria:             - *by frame*: Rejects movies with drifts between frames                               bigger than a certain maximum.             - *by whole movie*: Rejects movies with a total travel                                          bigger than a certain maximum.             - *by frame and movie*: Rejects movies if both conditions                                                 above are met.             - *by frame or movie*: Rejects movies if one of the conditions                                              above are met.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtDenoiseParticles": {
        "name": "denoise particles",
        "Description": " Remove particles noise by filtering them.      This filtering process is based on a projection over a basis created     from some averages (extracted from classes). This filtering is not      intended for processing particles. The huge filtering they will be      passed through is known to remove part of the signal with the noise.      However this is a good method for clearly see which particle are we      going to process before it's done.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Filter"
            ]
        ]
    },
    "XmippProtSimulateCTF": {
        "name": "simulate ctf",
        "Description": "     Simulate the effect of the CTF (no amplitude decay).     A random defocus is chosen between the lower and upper defocus for each projection.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Filter"
            ]
        ]
    },
    "XmippProtComputeLikelihood": {
        "name": "log likelihood",
        "Description": "This protocol computes the log likelihood or correlation of a set of particles with assigned angles when compared to a set of maps or atomic models",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Filter"
            ]
        ]
    },
    "XmippProtImageOperateParticles": {
        "name": "operate particles",
        "Description": "Performs operations between two sets of particles or to a set of particles. The mathematical operations are: plus, minus multiply, divide, minimum, maximum, dot product, log, log10, sqrt, abs, pow, column, slice, row, mn, radial average or reset. This protocol supports comparative analysis or creation of difference maps between conditions.  ",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Calculators"
            ]
        ]
    },
    "XmippProtImageOperateVolumes": {
        "name": "operate volumes",
        "Description": " A Executes arithmetic operations between two volumesor to a volume. The mathematical operations are: plus, minus multiply, divide, minimum, maximum, dot product, log, log10, sqrt, abs, pow, column, slice, row, mn, radial average or resetThis enables structural comparisons, highlighting conformational changes or shared features between datasets.",
        "Tags": [
            [
                "Protocols SPA",
                "Tools",
                "Calculators"
            ]
        ]
    },
    "XmippProtCropResizeParticles": {
        "name": "crop/resize particles",
        "Description": " Crop or resize a set of particles ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Preprocess"
            ]
        ]
    },
    "XmippProtCropResizeVolumes": {
        "name": "crop/resize volumes",
        "Description": "Crops or resizes 3D volumes to a desired size or region of interest. This protocol helps optimize memory usage and focus on relevant structural areas for analysis or comparison.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtCreateMask3D": {
        "name": "create 3d mask",
        "Description": " Create a 3D mask.     The mask can be created with a given geometrical shape (Sphere, Box,     Cylinder...) or it can be obtained from operating on a 3d volume or a     previous mask.     ",
        "Tags": [
            [
                "Tomography",
                "Particles",
                "Preprocess"
            ]
        ]
    },
    "XmippProtCreateMask2D": {
        "name": "create 2d mask",
        "Description": " Create a 2D mask.     The mask can be created with a given geometrical shape (Circle, Rectangle,     Crown...) or it can be obtained from operating on a 2d image or a previuous     mask. ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Mask"
            ]
        ]
    },
    "XmippProtMaskParticles": {
        "name": "xmipp prot mask particles",
        "Description": " This class implement the common features for applying a mask with Xmipp either SetOfParticles, Volume or SetOfVolumes objects.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Mask"
            ]
        ]
    },
    "XmippProtMaskVolumes": {
        "name": "xmipp prot mask volumes",
        "Description": " This class implement the common features for applying a mask with Xmipp either SetOfParticles, Volume or SetOfVolumes objects.     ",
        "Tags": [
            [
                "Tomography",
                "Particles",
                "Preprocess"
            ]
        ]
    },
    "XmippProtMovieResize": {
        "name": "movie resize",
        "Description": "     Resize a set of movies. Only downsampling is allowed.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtAddNoiseVolumes": {
        "name": "xmipp prot add noise volumes",
        "Description": "         Given a sets of volumes or particles the protocol adds noise to them      The types of noise are Uniform, Student and Gaussian.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtAddNoiseParticles": {
        "name": "xmipp prot add noise particles",
        "Description": "         Given a sets of volumes or particles the protocol adds noise to them      The types of noise are Uniform, Student and Gaussian.     ",
        "Tags": [
            [
                "Protocols SPA",
                "Movies"
            ]
        ]
    },
    "XmippProtFilterParticles": {
        "name": "filter particles",
        "Description": " Applies Fourier-based filters to a set of particles to enhance or suppress specific frequency components. This helps improve contrast or remove noise, preparing particles for further analysis such as picking. ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Filter"
            ]
        ]
    },
    "XmippProtFilterVolumes": {
        "name": "filter volumes",
        "Description": " Applies Fourier filters to 3D volumes, adjusting their frequency content generating a filter volume as output. Filtering can emphasize structural features, reduce noise, or prepare volumes for comparison or refinement. The filter can be applied in Fourier, wavelet or real space, and can be set as band, high or low pass filter. Also can be set the resolution range and the decay length ",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtPreprocessParticles": {
        "name": "preprocess particles",
        "Description": "Preprocesses particle images by applying the optional steps:  dust removal, randomize phase, normalize, center images, phase flip images, invert contrast, threshold, fill with below, abs_bellow or above, a threshold grey value below which all voxels should be set to 0, fill value or substitute by value binarize or  average. This cleaning stage improves particle quality and consistency for downstream tasks.  ",
        "Tags": [
            [
                "Protocols SPA",
                "Particles",
                "Preprocess"
            ]
        ]
    },
    "XmippProtPreprocessVolumes": {
        "name": "preprocess volumes",
        "Description": "Preprocesses 3D volumes using Xmipp tools to prepare them for further analysis. Operations include: normalization, change hand, change icosahedral orientation, randomize phase, symmetry, symmetry group, aggregation mode, wrap, apply Laplacian, mask volume. adjust gray value, segment, normalize background, invert contrast and threshold.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Preprocess"
            ]
        ]
    },
    "XmippProtProjMatch": {
        "name": "projection matching",
        "Description": " Performs 3D reconstruction and classification using multireference projection matching. This method assigns images to references and reconstructs volumes, allowing for the separation of structural classes.",
        "Tags": [
            [
                "Protocols SPA",
                "3D",
                "Refine"
            ]
        ]
    }
};

// Construir grafo jerÃ¡rquico
function buildHierarchicalGraph(data) {
  const nodes = [];
  const links = [];
  const level1Set = new Set();
  const level2Set = new Set();
  const level3Set = new Set();

  Object.entries(data).forEach(([id, proto]) => {
    const tags = proto.Tags[0];
    const lvl1 = tags[0], lvl2 = tags[1], lvl3 = tags[2];

    if (!level1Set.has(lvl1)) { nodes.push({id:`lvl1-${lvl1}`, type:"lvl1", nombre:lvl1}); level1Set.add(lvl1); }
    if (lvl2 && !level2Set.has(lvl1+"-"+lvl2)) {
      nodes.push({id:`lvl2-${lvl1}-${lvl2}`, type:"lvl2", nombre:lvl2});
      links.push({source:`lvl1-${lvl1}`, target:`lvl2-${lvl1}-${lvl2}`});
      level2Set.add(lvl1+"-"+lvl2);
    }
    if (lvl3 && !level3Set.has(lvl1+"-"+lvl2+"-"+lvl3)) {
      nodes.push({id:`lvl3-${lvl1}-${lvl2}-${lvl3}`, type:"lvl3", nombre:lvl3});
      links.push({source:`lvl2-${lvl1}-${lvl2}`, target:`lvl3-${lvl1}-${lvl2}-${lvl3}`});
      level3Set.add(lvl1+"-"+lvl2+"-"+lvl3);
    }

    nodes.push({id, type:"protocol", nombre:proto.name, descripcion:proto.Description});
    const parentId = lvl3 ? `lvl3-${lvl1}-${lvl2}-${lvl3}` : (lvl2 ? `lvl2-${lvl1}-${lvl2}` : `lvl1-${lvl1}`);
    links.push({source: parentId, target:id});
  });

  return {nodes, links};
}

const graph = buildHierarchicalGraph(data);

// Colores por nivel
const color = d3.scaleOrdinal()
  .domain(["lvl1","lvl2","lvl3","protocol"])
  .range(["#1f77b4","#ff7f0e","#2ca02c","#666"]);

const svg = d3.select("#graph").append("svg")
  .attr("width","100%").attr("height","100%");

const g = svg.append("g");
svg.call(d3.zoom().on("zoom", (event)=>{ g.attr("transform", event.transform); }));

const tooltip = d3.select("#tooltip");

const link = g.append("g")
  .attr("stroke","#aaa").attr("stroke-opacity",0.6)
  .selectAll("line").data(graph.links)
  .join("line").attr("stroke-width",1);

const node = g.append("g")
  .selectAll("circle").data(graph.nodes)
  .join("circle")
  .attr("r", d=>d.type==="protocol"?6:(d.type==="lvl1"?20:(d.type==="lvl2"?14:10)))
  .attr("fill", d=>color(d.type))
  .call(d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));

// Etiquetas para nodos de nivel 1 (y puedes hacer lvl2 similar)
const labels = g.append("g")
  .selectAll("text")
  .data(graph.nodes.filter(d => d.type === "lvl1")) // solo nivel 1
  .join("text")
  .text(d => d.nombre)
  .attr("font-size", "14px")
  .attr("font-weight", "bold")
  .attr("fill", "#000")
  .attr("text-anchor", "start") // texto a la derecha del nodo
  .attr("dy", "0.35em");        // centra verticalmente

// Etiquetas para nodos de nivel 2
const labels2 = g.append("g")
  .selectAll("text")
  .data(graph.nodes.filter(d => d.type === "lvl2"))
  .join("text")
  .text(d => d.nombre)
  .attr("font-size", "12px")      // mÃ¡s pequeÃ±o que nivel 1
  .attr("fill", "#333")
  .attr("text-anchor", "start")   // texto a la derecha
  .attr("dy", "0.35em");


node.on("mouseover", (event,d)=>{
  tooltip.transition().duration(200).style("opacity",0.95);
  if(d.type==="protocol"){
    tooltip.html(`<strong>${d.nombre}</strong><br/><br/>${d.descripcion}`);
  }else{ tooltip.html(`<strong>${d.type}:</strong> ${d.nombre}`); }
  tooltip.style("left",(event.pageX+15)+"px").style("top",(event.pageY+15)+"px");
}).on("mousemove",(event)=>{
  tooltip.style("left",(event.pageX+15)+"px").style("top",(event.pageY+15)+"px");
}).on("mouseout",()=>tooltip.transition().duration(200).style("opacity",0));


// Fuerza de repulsiÃ³n diferenciada por nivel
const chargeForce = d3.forceManyBody()
  .strength(d => {
    if(d.type === "lvl1") return -200;   // mÃ¡s repelidos
    if(d.type === "lvl2") return -70;    // menos repelidos
    if(d.type === "lvl3") return -40;    // aÃºn menos
    return -20;                          // protocolos
  });

const simulation = d3.forceSimulation(graph.nodes)
  .force("link", d3.forceLink(graph.links).id(d=>d.id).distance(50))
  .force("charge", chargeForce)
  .force("center", d3.forceCenter(window.innerWidth/2, window.innerHeight/2))
  .force("radial", d3.forceRadial(300, window.innerWidth/2, window.innerHeight/2).strength(0.1))
  .force("collide", d3.forceCollide().radius(d=>d.type==="protocol"?12:25));

simulation.on("tick", ()=>{
  link.attr("x1",d=>d.source.x).attr("y1",d=>d.source.y)
      .attr("x2",d=>d.target.x).attr("y2",d=>d.target.y);

  node.attr("cx",d=>d.x).attr("cy",d=>d.y);

  labels.attr("x", d => d.x + 22) // un poco a la derecha del nodo
        .attr("y", d => d.y);
  labels2.attr("x", d => d.x + 18) // un poco a la derecha del nodo
       .attr("y", d => d.y);
});

function dragstarted(event,d){if(!event.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y;}
function dragged(event,d){d.fx=event.x; d.fy=event.y;}
function dragended(event,d){if(!event.active) simulation.alphaTarget(0); d.fx=null; d.fy=null;}

// Leyenda
const legend = d3.select("#legend");
const lvl1Nodes = graph.nodes.filter(d=>d.type==="lvl1");
const lvl2Nodes = graph.nodes.filter(d=>d.type==="lvl2");

legend.append("strong").text("Level 1").append("br");
lvl1Nodes.forEach(d=>{
  const entry = legend.append("div");
  entry.append("span").style("background", color(d.type));
  entry.append("text").text(d.nombre);
});

legend.append("br").append("strong").text("Level 2").append("br");
lvl2Nodes.forEach(d=>{
  const entry = legend.append("div");
  entry.append("span").style("background", color(d.type));
  entry.append("text").text(d.nombre);
});
</script>
</body>
</html>

# **************************************************************************
# *
# * Authors:     J.M. De la Rosa Trevin (jmdelarosa@cnb.csic.es)
# *
# * Unidad de  Bioinformatica of Centro Nacional de Biotecnologia , CSIC
# *
# * This program is free software; you can redistribute it and/or modify
# * it under the terms of the GNU General Public License as published by
# * the Free Software Foundation; either version 2 of the License, or
# * (at your option) any later version.
# *
# * This program is distributed in the hope that it will be useful,
# * but WITHOUT ANY WARRANTY; without even the implied warranty of
# * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# * GNU General Public License for more details.
# *
# * You should have received a copy of the GNU General Public License
# * along with this program; if not, write to the Free Software
# * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
# * 02111-1307  USA
# *
# *  All comments concerning this program package may be sent to the
# *  e-mail address 'scipion@cnb.csic.es'
# *
# **************************************************************************
import pyworkflow.protocol.params as params
from pyworkflow.utils.properties import Message

import pwem.emlib.metadata as md
from pwem.emlib.image import ImageHandler
from pwem.objects import Particle
from pwem.protocols import ProtAlign2D
from pwem.constants import ALIGN_NONE

from xmipp3.convert import xmippToLocation, writeSetOfParticles

        
class XmippProtApplyAlignment(ProtAlign2D):
    """ Apply alignment parameters and produce a new set of images.

    (AI Generated):

    Purpose and Scope. This protocol applies the alignment transformations stored in a set of 2D particles and produces
    a new image stack with the aligned particle images. It is typically used after a 2D classification or alignment
    protocol where alignment parameters (rotations and shifts) have been computed and are stored in the particle
    metadata. Applying these transformations is useful for producing aligned averages, comparing image quality, or
    using the aligned images for further processing steps that assume pre-centered or co-oriented particles.

    Inputs. The input is a set of 2D particles with existing alignment parameters. These parameters are typically
    generated by protocols such as 2D classification or alignment and must be present in the particle metadata. Only
    particle sets with 2D alignment information can be selected as input.

    Protocol Behavior. The protocol first converts the input particle set into an Xmipp metadata format containing
    references to the image files along with their alignment parameters. It then uses the Xmipp program
    xmipp_transform_geometry to apply the stored transformations (rotations and translations) to each image. This
    results in a new image stack in which all particles are aligned according to their associated parameters. Once the
    images are transformed, they are loaded into a new set of particles with the alignment metadata removed
    (i.e., the output particles are treated as having no further alignment).

    The protocol also computes an average image from the aligned particles. This average serves as a visual summary of
    the aligned dataset and can be used to assess the success of the alignment process.

    Outputs. The main output is a new SetOfParticles containing the aligned images. Each particle is placed at its new
    location and stored with updated metadata. Additionally, the protocol produces an average image computed from all
    aligned particles. This average is saved as a single-particle object and made available as a separate output.

    User Workflow. The user selects a set of particles that already contain 2D alignment parameters. After launching
    the protocol, the transformation will be applied to each image, and the aligned particles and their average will be
    generated as outputs. The user can inspect the new aligned particle stack and average image in the Scipion viewer.
    These aligned images can then be used for further classification, template generation, or visual inspection.

    Interpretation and Best Practices. This protocol is purely geometric: it does not refine or compute any new
    alignment, but rather applies existing alignment data to the images. It is useful for visual verification of
    classification or alignment results, generating improved input for downstream analyses, or preparing particles for
    manual inspection. The computed average image can also help identify misalignments or confirm the centering of
    particle views. Since alignment metadata is removed in the output, further protocols will treat the resulting set
    as raw particles.
    """
    _label = 'apply alignment 2d'

    #--------------------------- DEFINE param functions --------------------------------------------
    def _defineParams(self, form):
        form.addSection(label='Input')
        form.addParam('inputParticles', params.PointerParam, important=True,  
                      pointerCondition='hasAlignment2D',
                      label=Message.LABEL_INPUT_PART, pointerClass='SetOfParticles',
                      help='Select the particles that you want to apply the'
                           'alignment parameters.')
        form.addParallelSection(threads=0, mpi=4)
    
    #--------------------------- INSERT steps functions --------------------------------------------
    
    def _insertAllSteps(self):
        """ Mainly prepare the command line for call cl2d align program"""
        
        # Create a metadata with the geometrical information 
        # as expected by Xmipp
        imgsFn = self._getPath('input_particles.xmd')
        self._insertFunctionStep('convertInputStep', imgsFn)
        self._insertFunctionStep('applyAlignmentStep', imgsFn)
        self._insertFunctionStep('createOutputStep')        

    #--------------------------- STEPS functions --------------------------------------------        
    
    def convertInputStep(self, outputFn):
        """ Create a metadata with the images and geometrical information. """
        writeSetOfParticles(self.inputParticles.get(), outputFn)
        
        return [outputFn]
    
    def applyAlignmentStep(self, inputFn):
        """ Create a metadata with the images and geometrical information. """
        outputStk = self._getPath('aligned_particles.stk')
        args = '-i %(inputFn)s -o %(outputStk)s --apply_transform ' % locals()
        self.runJob('xmipp_transform_geometry', args)
        
        return [outputStk]
     
    def createOutputStep(self):
        particles = self.inputParticles.get()

        # Generate the SetOfAlignmet
        alignedSet = self._createSetOfParticles()
        alignedSet.copyInfo(particles)

        inputMd = self._getPath('aligned_particles.xmd')
        alignedSet.copyItems(particles,
                             updateItemCallback=self._updateItem,
                             itemDataIterator=md.iterRows(inputMd, sortByLabel=md.MDL_ITEM_ID))
        # Remove alignment 2D
        alignedSet.setAlignment(ALIGN_NONE)

        # Define the output average

        avgFile = self._getExtraPath("average.xmp")

        imgh = ImageHandler()
        avgImage = imgh.computeAverage(alignedSet)

        avgImage.write(avgFile)

        avg = Particle()
        avg.setLocation(1, avgFile)
        avg.copyInfo(alignedSet)

        self._defineOutputs(outputAverage=avg)
        self._defineSourceRelation(self.inputParticles, avg)

        self._defineOutputs(outputParticles=alignedSet)
        self._defineSourceRelation(self.inputParticles, alignedSet)
    
    #--------------------------- INFO functions --------------------------------------------
    def _validate(self):
        errors = []
        return errors
        
    def _summary(self):
        summary = []
        if not hasattr(self, 'outputParticles'):
            summary.append("Output particles not ready yet.")
        else:
            summary.append("Applied alignment to %s particles." % self.inputParticles.get().getSize())
        return summary

    def _methods(self):
        if not hasattr(self, 'outputParticles'):
            return ["Output particles not ready yet."]
        else:
            return ["We applied alignment to %s particles from %s and produced %s."
                    % (self.inputParticles.get().getSize(), self.getObjectTag('inputParticles'), self.getObjectTag('outputParticles'))]
    
    #--------------------------- UTILS functions --------------------------------------------
    def _updateItem(self, item, row):
        """ Implement this function to do some
        update actions over each single item
        that will be stored in the output Set.
        """
        # By default update the item location (index, filename) with the new binary data location
        newFn = row.getValue(md.MDL_IMAGE)
        newLoc = xmippToLocation(newFn)
        item.setLocation(newLoc)
        # Also remove alignment info
        item.setTransform(None)

